goog.provide('three7.game.Block');

/**
 * Class that implements a Three7's block.
 */
three7.game.Block = function(logic, index, position, number) {
  this.logic = logic;
  this.index = index;
  this.isDirty = true;
  this.position = position;
  // draw random number from bag if none is passed
  this.number = (typeof number === 'undefined') ? logic.drawBlock() : number;
};

/**
 * Unset block from grid.
 */
three7.game.Block.prototype.unsetFromGrid = function() {
  this.logic.grid.unsetBlock(this);
};

/**
 * Set block from grid.
 */
three7.game.Block.prototype.setToGrid = function() {
  this.logic.grid.setBlock(this);
};

/**
 * Set block's position.
 */
three7.game.Block.prototype.setPosition = function(x, y) {
  if ((this.position.x != x) || (this.position.y != y)) {
    this.isDirty = true;
    this.position.x = x;
    this.position.y = y;
  }
};

/**
 * Check whether block can occupy the specified position.
 */
three7.game.Block.prototype.canOccupy = function(x, y) {
  var block = this.logic.grid.blockAt(x, y);
  // there is no block there we're refering to this one?
  return (block === null) || (block === this);
};

/**
 * Check whether block can occupy the specified offset.
 */
three7.game.Block.prototype.canOccupyOffset = function(x, y) {
  return this.canOccupy(this.position.x + x, y2 = this.position.y + y);
};

/**
 * Move block by x, y units in the grid.
 */
three7.game.Block.prototype.moveBy = function(x, y) {
  this.setPosition(this.position.x + x, this.position.y + y);
};

/**
 * Get the largest range of blocks for making sequences.
 */
three7.game.Block.prototype.largestSequenceRange = function(horizontal) {
  var x = 0, y = 1, block, sum, blocks = [];
  if (horizontal === true) {
    x = 1;
    y = 0;
  }
  // three seven?
  if (this.number == 7) {
    // negative direction
    for (block = this, sum = 0; ((block) && (sum < 3) && (block.number == 7)); ++sum) {
      blocks.unshift(block);
      block = this.logic.grid.blockAt(block.position.x - x, block.position.y - y);
    }
    // positive direction
    for (block = this, sum = 0; ((block) && (sum < 3) && (block.number == 7)); ++sum) {
      if (block != this) {
        blocks.push(block);
      }
      block = this.logic.grid.blockAt(block.position.x + x, block.position.y + y);
    }
  }
  else {
    // negative direction
    for (block = this, sum = 0; ((block) && ((sum + block.number) <= 7));) {
      sum += block.number;
      blocks.unshift(block);
      block = this.logic.grid.blockAt(block.position.x - x, block.position.y - y);
    }
    // positive direction
    for (block = this, sum = 0; ((block) && ((sum + block.number) <= 7));) {
      sum += block.number;
      if (block != this) {
        blocks.push(block);
      }
      block = this.logic.grid.blockAt(block.position.x + x, block.position.y + y);
    }
  }
  return blocks;
};

/**
 * Get sequence blocks generated by given blocks.
 */
three7.game.Block.prototype.extractSequenceBlocks = function(blocks) {
  var i, j, k, sum, len = blocks.length, isSequence, sequences = [];
  // try all sequences
  for (i = 0; i < len - 1; ++i) {
    isSequence = false;
    // start of a three-seven sequence?
    if (blocks[i].number === 7) {
      for (j = i + 1; (j < len) && ((i + 3) > j) && (blocks[j].number === 7); ++j) {
        sum += blocks[j].number;
      }
      // did we get three consecutive 7s?
      isSequence = ((i + 3) === j);
    }
    else {
      for (j = i, sum = 0; (j < len) && (sum < 7); ++j) {
        sum += blocks[j].number;
      }
      // did we get at least 2 numbers whose sum is 7?
      isSequence = ((sum === 7) && (j >= (i + 2)));
    }
    // we got a sequence?
    if (isSequence) {
      for (k = i; k < j; ++k) {
        sequences.push(blocks[k]);
      }
    }
  }
  return sequences;
};

/**
 * Get sequence blocks generated by given blocks.
 */
three7.game.Block.prototype.sequenceBlocks = function() {
  var sequences, blocks;

  // get horizontal range of blocks for possible sequences
  blocks = this.largestSequenceRange(true);
  blocks = this.extractSequenceBlocks(blocks);
  sequences = blocks;

  // get vertical range of blocks for possible sequences
  blocks = this.largestSequenceRange(false);
  blocks = this.extractSequenceBlocks(blocks);
  sequences = sequences.concat(blocks);
  return sequences;
};
